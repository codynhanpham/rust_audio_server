use std::{
    fs,
    fs::OpenOptions,
    io::Write,
    sync::{Arc, Mutex},
};

use actix_web::{get, web, App, HttpServer, HttpResponse, Responder};
use chrono::Utc;
use local_ip_address::local_ip;
use rodio::{OutputStream, Sink, Source};

mod structs;
use structs::{ResponseMessage, QueryStruct, AudioFiles};

mod audio;
use audio::{preload_audio_files, handle_audio_error};

mod file_io;
use file_io::make_batch_zip_file;


// Define the global variable for the log file name
// This will be updated whenever a new /startnewlog request is received
lazy_static::lazy_static! {
    static ref LOG_FILE_NAME: Arc<Mutex<String>> = Arc::new(Mutex::new(Utc::now().format("logs/log_%Y%m%d-%H%M%S").to_string()));
}

// Define the port number
static PORT: u16 = 5055;



/// ---------- APP & ROUTES ---------- ///

#[get("/")]
async fn index() -> impl Responder {
    "
    Available routes:
        - GET /ping\t\t\t\t --> pong
        - GET /play/{audio_file_name}\t\t --> play the audio file
        - GET /startnewlog\t\t\t --> start a new log file
        - GET /generate_batch_files\t\t --> generate a .zip containing batch files to request the audio files (close when audio file is finished playing)
        - GET /generate_batch_files_async\t --> generate a .zip containing batch files to request the audio files (asynchronous, close immediately)

    Note:
        - The batch files generated by /generate_batch_files and /generate_batch_files_async are for Windows only.
    "
}


#[get("/ping")]
async fn ping() -> impl Responder {
    let time_ns = std::time::SystemTime::now().duration_since(std::time::SystemTime::UNIX_EPOCH).unwrap().as_nanos();
    println!("{}: Received /ping", time_ns);
    HttpResponse::Ok().body("pong")
}


#[get("/play/{audio_file_name}")]
async fn play(audio_files: web::Data<AudioFiles> , audio_file_name: web::Path<String>, query: web::Query<QueryStruct>) -> HttpResponse {
    let time_ns = std::time::SystemTime::now().duration_since(std::time::SystemTime::UNIX_EPOCH).unwrap().as_nanos();
    println!("{}: Received /play/{}", time_ns, audio_file_name);

    let audio_file_name = audio_file_name.into_inner();
    let source = audio_files.files.get(&audio_file_name); // find decoded audio file by name

    // if the audio file is not found, return 404
    if source.is_none() {
        println!("\x1b[2m    \x1b[31mAudio file Not Found\x1b[0m");
        let message = format!("Audio file {} not found", audio_file_name);
        return HttpResponse::NotFound().json(ResponseMessage { message });
    }

    // Linux with ALSA will panic here if there is no audio output device available
    let output_stream_result = std::panic::catch_unwind(|| OutputStream::try_default());

    if output_stream_result.is_err() {
        return handle_audio_error(&audio_file_name, &query.time, "OutputStream NoDevice", &LOG_FILE_NAME);
    }

    let output_stream_result = output_stream_result.unwrap();

    // Windows somehow panics when unwraping the output_stream_result for the same reason (no audio output device available)
    if let Err(e) = output_stream_result {
        return handle_audio_error(&audio_file_name, &query.time, &e.to_string(), &LOG_FILE_NAME);
    }

    // now safe to unwrap
    let (_stream, stream_handle) = output_stream_result.unwrap();

    // print the source sample rate
    println!("\x1b[2m    \x1b[38;5;8mSource sample rate: {}\x1b[0m", source.unwrap().sample_rate());


    let sink = Sink::try_new(&stream_handle).unwrap();
    sink.append(source.unwrap().clone()); // init the sink with the audio file

    let time_start_nano = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos();
    
    println!("\x1b[2m    \x1b[38;5;8m{}: Started {}...\x1b[0m", time_start_nano, audio_file_name);
    sink.sleep_until_end(); // play the audio file synchronously. this thread will be blocked until the audio file has finished playing.
    println!("\x1b[2m    \x1b[38;5;8mFinished (job at {})\x1b[0m", time_start_nano);

    let message = format!("At {} played {}", time_start_nano, audio_file_name);
    drop(sink);
    drop(stream_handle);
    drop(_stream);
    
    // Append to the log file
    fs::create_dir_all("./logs").unwrap(); // make sure the logs/ folder exists first

    let log_file_name = LOG_FILE_NAME.lock().unwrap();
    let mut file = OpenOptions::new()
        .write(true)
        .append(true)
        .create(true)
        .open(format!("{}.csv", *log_file_name))
        .unwrap();
    if let Err(e) = writeln!(file, "{},{},{},{}", time_start_nano, audio_file_name, "success", &query.time) {
        eprintln!("Couldn't write to file: {}", e);
    } else {
        println!("\x1b[2m    \x1b[38;5;8mAppended to log file: {}\x1b[0m", *log_file_name);
    }

    drop(log_file_name); // release the lock
    drop(file); // release the lock

    HttpResponse::Ok().json(ResponseMessage { message })
}


#[get("/startnewlog")]
async fn start_new_log() -> impl Responder {
    let time_ns = std::time::SystemTime::now().duration_since(std::time::SystemTime::UNIX_EPOCH).unwrap().as_nanos();
    println!("{}: Received /startnewlog", time_ns);

    // make sure the log folder exists
    fs::create_dir_all("./logs").unwrap();

    let mut log_file_name = LOG_FILE_NAME.lock().unwrap();
    *log_file_name = Utc::now().format("logs/log_%Y%m%d-%H%M%S").to_string(); // update log file name

    // create new log file
    let mut file = OpenOptions::new()
        .write(true)
        .append(true)
        .create(true)
        .open(format!("{}.csv", *log_file_name))
        .unwrap();
    let mut message = format!("Started new log file: ./{}.csv", *log_file_name);
    drop(log_file_name);

    if let Err(e) = writeln!(file, "timestamp_audio,audio_filename,status,timestamp_client") {
        eprintln!("Couldn't create new file: {}", e);

        message = format!("Error: Couldn't create new file: {}", e);
    }

    drop(file);

    println!("\x1b[2m    \x1b[38;5;8m{}\x1b[0m", message);
    HttpResponse::Ok().json(ResponseMessage { message })
}


#[get("/generate_batch_files")]
async fn generate_batch_files(audio_files: web::Data<AudioFiles>) -> HttpResponse {
    let time_ns = std::time::SystemTime::now().duration_since(std::time::SystemTime::UNIX_EPOCH).unwrap().as_nanos();
    println!("{}: Received /generate_batch_files", time_ns);

    let host_ip = local_ip().unwrap();
    let host_ip = host_ip.to_string();
    
    // create a zip file containing all the batch files
    let zip_file = make_batch_zip_file(&audio_files, &host_ip, false);

    println!("\x1b[2m    \x1b[38;5;8mHost IP (this server): {} - Port: {}\x1b[0m", host_ip, PORT);
    println!("\x1b[2m    \x1b[38;5;8mGenerated batch files for {} audio files\x1b[0m", audio_files.files.len());

    // return the zip file
    HttpResponse::Ok()
        .content_type("application/zip")
        .append_header(("Content-Disposition", format!("attachment; filename=\"{}_{}.zip\"", host_ip, PORT)))
        .body(zip_file)
}

#[get("/generate_batch_files_async")]
async fn generate_batch_files_async(audio_files: web::Data<AudioFiles>) -> HttpResponse {
    let time_ns = std::time::SystemTime::now().duration_since(std::time::SystemTime::UNIX_EPOCH).unwrap().as_nanos();
    println!("{}: Received /generate_batch_files_async", time_ns);

    let host_ip = local_ip().unwrap();
    let host_ip = host_ip.to_string();
    
    // create a zip file containing all the batch files
    let zip_file = make_batch_zip_file(&audio_files, &host_ip, true);

    println!("\x1b[2m    \x1b[38;5;8mHost IP (this server): {} - Port: {}\x1b[0m", host_ip, PORT);
    println!("\x1b[2m    \x1b[38;5;8mGenerated batch files for {} audio files\x1b[0m", audio_files.files.len());

    // return the zip file
    HttpResponse::Ok()
        .content_type("application/zip")
        .append_header(("Content-Disposition", format!("attachment; filename=\"{}_{}_async.zip\"", host_ip, PORT)))
        .body(zip_file)
}


#[actix_web::main]
async fn main() -> std::io::Result<()> {
    println!(" ---------- AUDIO SERVER ----------\n");
    println!("Looking for audio files in ./audio/*.wav ...");

    // preload audio files
    let audio_files = web::Data::new(AudioFiles {
        files: preload_audio_files("./audio"),
    });

    // make sure the log folder exists
    fs::create_dir_all("./logs").unwrap();

    // init a new log file name with the current date time
    let mut log_file_name = LOG_FILE_NAME.lock().unwrap();
    *log_file_name = Utc::now().format("logs/log_%Y%m%d-%H%M%S").to_string(); // update log file name
    
    
    // create new log file
    let mut file = OpenOptions::new()
        .write(true)
        .append(true)
        .create(true)
        .open(format!("{}.csv", *log_file_name))
        .unwrap();
    if let Err(e) = writeln!(file, "timestamp_audio,audio_filename,status,timestamp_client") {
        eprintln!("Couldn't create new file: {}", e);
    } else {
        println!("Started new log file: ./{}.csv\n", *log_file_name);
    }

    drop(log_file_name); // release the lock
    drop(file); // release the lock


    // start the server
    let host_ip = local_ip().unwrap();
    let host_ip = host_ip.to_string();
    println!("Server running at http://{}:{}/\n\n", host_ip, PORT);
    HttpServer::new(move || {
        App::new()
            .app_data(audio_files.clone())
            .service(index)
            .service(ping)
            .service(play)
            .service(start_new_log)
            .service(generate_batch_files)
            .service(generate_batch_files_async)
    })
    .bind(("0.0.0.0", PORT))? // bind to all interfaces
    .run()
    .await
}